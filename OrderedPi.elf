nm : type.

tm : type.

| : tm -> tm -> tm. %infix none 1 |.
new : (nm -> tm) -> tm.
out : nm -> nm -> nm -> tm.
>in : nm -> (nm -> tm) -> nm -> tm.
in< : nm -> (nm -> tm) -> nm -> tm.

0 : tm.
<-> : nm -> nm -> tm. %infix none 1 <->.

== : tm -> tm -> type. %infix none 0 ==.
==/com : P == Q <- Q == P.
==/par/tran : (P | Q) | R == P | (Q | R).

==/par/0 : P | 0 == P.
==/seq/0/l : P | 0 == P.
==/seq/0/r  : 0 | P == P.
==/res/com : (new [x] new [y] F x y) == (new [y] new [x] F x y).
==/res/0 : (new [x] 0) == 0.
==/res-par : (new [x] P x | Q) == (new [x] P x) | Q.

==/eq : P == P.
==/new : (new [x] P x) == (new [x] P' x) 
      <- {x} P x == P' x.
==/par : P | Q == P' | Q'
      <- Q == Q'
      <- P == P'.

==/seq : P | Q == P' | Q'
      <- Q == Q'
      <- P == P'.

==/out : out X Y X' == out X Y X'.
==/>in : >in X P X' == >in X P' X'
      <- {x} P x == P' x. 

==/in< : in< X P X' == in< X P' X'
      <- {x} P x == P' x. 
=> : tm -> tm -> type. %infix none 0 =>.

=>/eq : P == P' 
     -> P' => Q'
     -> Q' == Q 
     -> P => Q.

=>/red/l : out X Y | >in X F => F Y.

=>/red/l : in< X F | out X Y => F Y.

=>/par/l : P | R => P' | R 
        <- P => P'.

=>/par/r : P | R => P | R' 
        <- R => R'.

=>/new : (new [x] P x ) => (new [x] P' x)
      <- {x} P x => P' x.


linear : (nm -> tm) -> type.
linear/par/l : linear P 
            -> linear [x] P x | Q. 
linear/par/r : linear Q 
            -> linear [x] P | Q x.
linear/new : linear ([x] new [y] F y x)
          <- {y} linear [x] F y x.
linear/in</use : linear [x] in< X F.
linear/in</other : linear ([x] in< Y (F x))
                <- {y} linear [x] F y x.

linear/>in/use : linear [x] >in X F.
linear/>in/other : linear ([x] >in Y (F x))
                <- {y} linear [x] F y x.

linear/out/use1 : linear [x] out x Y.
linear/out/use2 : linear [x] out X x.

linear/out/other : linear F 
                -> linear [x] out X Y (F x).

linear/<-> : linear [x] (x <-> Y).


head : (nm -> tm) -> type.
tail : (nm -> tm) -> type.

tp : type.

->> : tp -> tp -> tp. %infix right 0 ->>.
>-> : tp -> tp -> tp. %infix right 0 >->.

assm : nm -> tp -> type.

is : tm -> nm -> tp -> type.

is/id : is (Y <-> X) X A
     <- assm Y B.

is/->>R : is (>in X F) X (A ->> B)
       <- tail F
       <- {y} assm y A -> is (F y) X B.

is/->>L : is P Y A
      -> ({x} assm x B -> is (Q x) Z C)
      -> ({x} assm x (A ->> B) -> is (new [y] P | out x y (Q x)) Z C).

is/>->R : is (in< X F) X (A >-> B)
       <- head F
       <- {y} assm y A -> is (F y) X B.

is/>->L : is P Y A
      -> ({x} assm x B -> is (Q x) Z C)
      -> ({x} assm x (A >-> B) -> is (new [y] (out x y P | Q x)) Z C).


%{



some reduction rules

Gm |- Pl | Pr :: x : A      Gl,x:A,Gr |- Pm :: z : C
----------------------------------------------------- cut
  Gl,Gm,Gr |- #x. Pl | Pm | Pr :: z : C

===========================================================================================================

can y be bound in Pl, and Pr but not Pm
and x be bound in Pl and Pm but not Pr in Pl | Pm | Pr ?  (yes) this is just hard to write linearly. 

 Gl', y : A |- Pl | Pr :: x' : B                 Gr' |- Pl' :: y : A             Gl, x' : B , Gr |- Pr' :: z : C
--------------------------------------         ----------------------------------------------------------------
Gl' |- Pl | x(y, x').Pr :: x : A ->> B        Gl, x:A ->> B, Gr' , Gr |- #x'. #y.(Pl' | Pr' | x<y, x'>) :: z : C
--------------------------------------------------------------------------------------------------------------
       Gl,Gl',Gr',Gr |- #x. Pl | (#y. #x'.(Pl' | Pr' | x<y, x'>)) | x(y,x').Pr :: z : C


                            Gl', y : A |- Pl | Pr :: x' : B      Gl, x' : B , Gr |- Pr' :: z : C
                            ----------------------------------------------------------------------
Gr' |- Pl' :: y : A                  Gl, Gl', y: A, Gr |- #x' .(Pl | Pr' | Pr) :: z : C
----------------------------------------------------------------------------------------------------
          Gl, Gl' , Gr', Gr |- #y. Pl' | #x'.(Pl | Pr' | Pr) :: x'' : B


                            Gl', y : A |- Pl | Pr :: x' : B      Gl, x' : B , Gr |- Pl' :: z : C
                            ----------------------------------------------------------------------
Gr' |- Pr' :: y : A                  Gl, Gl', y: A, Gr |- #x' .(Pl | Pl' | Pr) :: z : C
----------------------------------------------------------------------------------------------------
          Gl, Gl' , Gr', Gr |- #y. #x'.(Pl | Pr' | Pr) | Pr' :: x'' : B


===========================================================================================================
===========================================================================================================

This appears to work!

Gm |- Pm :: x : A      Gl,x:A,Gr |- Pl | Pr :: z : C
----------------------------------------------------- cut
  Gl,Gm,Gr |- 0| #x. Pl | Pm | Pr :: z : C

===========================================================================================================

can y be bound in Pl, and Pr but not Pm
and x be bound in Pl and Pm but not Pr in Pl | Pm | Pr ?  (yes) this is just hard to write linearly. 

 Gl', y : A |- Pr' :: x' : B                Gr' |- Pl :: y : A             Gl, x' : B , Gr |- Pl' | Pr :: z : C
-----------------------------------      -------------------------------------------------------------------------
Gl' |- x(y, x').Pr' :: x : A ->> B        Gl, x:A ->> B, Gr' , Gr |- (#x'. #y.(Pl | Pl' | x<y, x'>)) | Pr :: z : C
-------------------------------------------------------------------------------------------------------------------
       Gl,Gl',Gr',Gr |- 0 | #x.((#y.#x'.(Pl | Pl' | x<y, x'>)) | x(y,x').Pr' | Pr):: z : C


                                  Gl', y : A |- Pr' :: x' : B     Gl, x' : B , Gr |- Pl' | Pr :: z : C
                                 ----------------------------------------------------------------------
Gr' |- Pl :: y : A                            Gl,Gl',y:A,Gr |- 0|#x'.(Pl' | Pr' | Pr) :: z : C
-----------------------------------------------------------------------------------------------
            Gl,Gl',Gr',Gr |- 0 | #y.(0| Pl | #x'.(Pl' | Pr' | Pr)) :: z : C



Q | x(y).P => x(y). Q | P
Q.(y)x | P => (Q | P).(y)x

