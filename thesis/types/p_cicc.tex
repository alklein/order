\section[$CICC$]{Caledon Implicit Calculus of Constructions}

% -------------------------------------------------------------

\subsection{Overview}

\begin{frame}
\frametitle{Caledon Implicit Calculus of Constructions}
\begin{itemize}
\item $CICC$ is typed by transformation into $CC$.
\item Based on the ``Bicolored Calculus of Constructions'' ($CC^{Bi}$) \citep{luther2001more}.
\item includes a form of non alpha convertible binding.
\item interpretation of the unification problem form ($UPF$) generated by elaboration.
\end{itemize}
\end{frame}


% -------------------------------------------------------------


\subsection{Definition}

\begin{frame}
\frametitle{Syntax}
\begin{definition}
\textbf{(CICC Syntax)}
\[ 
E ::= 
V 
\orr S 
\orr E\;E 
\orr \lambda V : T. E 
\orr ?\lambda V : T. E 
\orr \Pi V : E . E 
\orr ?\Pi V : E . E 
\orr E \{ V : E = E \}
\]

\end{definition}

\begin{itemize}
\item The \textit{dependent} explicit and implicit products are written $\Pi v : E . E $ and $?\Pi v : A . E$. 
\item The \textit{non-dependent} explicit and implicit products are written $T \rightarrow T$ 
      and $T \Rightarrow T$ respectively.
\end{itemize}
\end{frame}


% -------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Definition Extraction}
We care about the transforming the constrained binders.
We interpret names as a kind of record modifier.
\begin{lstlisting}
defn nat : prop 
  as [a : prop] a -> (a -> a) -> a

defn nat_1 : nat -> prop
  as \ N : nat . [a : nat -> prop] a zero -> succty a -> a N

defn rec : nat -> prop -> prop
  as \ nm : nat . \ N : kind . nat_1 nm * N

defn get : [N : kind] [nm : nat] nat_1 nm * N -> N
  as \ N : kind . \nm : nat . \ c : (nat_1 nm, N) . snd c

defn put : [N : kind] [nm : nat] nat_1 nm ->  N -> nat_1 nm * N
  as \ N : kind . \ nm : nat . \nmnm : nat_1 nm . \ c : N . pair nmnm N
\end{lstlisting}
\end{frame}



% -------------------------------------------------------------
\newcommand{\CICCproj}[1]{ \left\llbracket #1 \right\rrbracket_{ci}}

\begin{frame}
\frametitle{Extraction}

\begin{definition}

\textbf{ (Projection from $CICC$ to $CC$) }

\[
\CICCproj{v} := v
\]\[
\CICCproj{s} := s
\]\[
\CICCproj{E_1 \; E_2} := \CICCproj{E_1} \; \CICCproj{E_2}
\]\[
\CICCproj{E_1 \; \{ x : T = E \}} := \CICCproj{E_1} \; (\m{put}\;\CICCproj{T}\;\bar{x}\; \bar{\bar{x}}; \CICCproj{E_2} )
\]\[
\CICCproj{\lambda v : T . E } := \lambda v : \CICCproj{T} . \CICCproj{E}
\]\[
\CICCproj{?\lambda v : T . E } := \lambda y : \m{rec}\;\bar{v}\; \CICCproj{T} . \CICCproj{ [ \m{get}\; \CICCproj{T}\; \bar{v}\; y  / v ] E}
\]\[
\CICCproj{\Pi v : T . E } := \Pi v : \CICCproj{T} . \CICCproj{E}
\]\[
\CICCproj{?\Pi v : T . E } := \Pi y : \m{rec}\;\bar{v}\;\CICCproj{T} . \CICCproj{ [ \m{get}\;\CICCproj{T}\; \bar{v}\; y  / v ] E}
\]

where $y$ is generally fresh
\end{definition}
\end{frame}


% -------------------------------------------------------------

\begin{frame}
\frametitle{Extraction Example}
\begin{example}
$N \{ x\; : \; T \; = \;A \} $
would become $N\;( \m{put} \; T \; \bar{x} \; \bar{\bar{x}} \; A)$.
\end{example}
\end{frame}


% -------------------------------------------------------------

\begin{frame}
\frametitle{Typing}


\begin{definition}
\textbf{(Typing for $CICC$)} We say $\Gamma \vdash_{ci} A : T$ iff $\CICCproj{\Gamma} \vdash_{cc} \CICCproj{A} : \CICCproj{T}$
\label{cicc:typing}
\end{definition}

\end{frame}

% -------------------------------------------------------------

\subsection{Results}

\begin{frame}
\frametitle{Initial Theorems}

We need to ensure that extraction preserves substitution.

\begin{theorem}
\textbf{(Projection Substitution)}  

$\CICCproj{[A/x] B} = [ \CICCproj{A} / x ] \CICCproj{B}$ provided $x$ is free for $A$ in $B$.

\end{theorem}

Reductions in $CICC$ also correspond to reductions in $CC$.

\begin{lemma}
\textbf{(Reduction Translation)}
Forall $M, N \in \m{Term}_{ci}$ if $M \rightarrow_{\beta\eta*} N$ then 
$\CICCproj{M} \rightarrow_{\beta\eta*} \CICCproj{N}$
\label{cicc:red}
\end{lemma}

\end{frame}

% -------------------------------------------------------------

\begin{frame}
\frametitle{Semantic Equivalence}

Semantic Equivalence ensures that reductions in $CC$ correspond to reductions in $CICC$.

\begin{theorem}
\textbf{(Semantic Equivalence)}

Forall $M \in \m{Term}_{ci}$ such that $\CICCproj{M} \rightarrow_{\beta\eta*} N'$ and 
$\Gamma \vdash M : T$ implies that there exists $M' \in \m{Term}_{cicc}$ such that 
$M \rightarrow_{\beta\eta*} M'$ and $\CICCproj{M'} \equiv N'$

\end{theorem}
\end{frame}

% -------------------------------------------------------------

\begin{frame}
\frametitle{Strong Normalization}

Strong normalization gives us consistency.

\begin{theorem}
\textbf{(Strong Normalization)} $\forall M \in \m{Term}_{ci}. SN(M)$
\label{ci:sn}
\end{theorem}


\end{frame}

