\section{Type Inference}

While the generation of unification problems is straightforward as described in the previous
sections, the implementations of the higher order pattern unification algorithm
is somewhat more convoluted. If it were to be implemented in Ollibot \citep{pfenning2009substructural} a much simpler, 
yet significantly less efficient, implementation might be possible.

It is first necessary to note that univerally quantified and lambda quantified variables
are easily represented by DeBruijn indexes, since no universal quantifiers are ever
introduced between two preexisting universal quantifiers. On the other hand, existential
variables are introduced all over the place. Rather than complicating substitution,
these are represented by unique names with depth indexes instead of height indexes.
Because they are not explicitly quantified, each existential variable instance carries its
own type, lifted to the location of the instance.

Since such a representation requires traversals and modifications of a tree structure,
it is natural to use a zipper to represent the entire structure. As traversing the structure
downwards also builds a context of universal variables and passed conjunctive
paths, the same zipper structure could be used as the type context for DeBruijn variable
lookup. In an imperative language with effects, this might lead to the assumption that
the use of a vector to hold the zipper context of the unification problem is optimal. However,
since nondeterminism is essential to proof search, difficult complications would
arise if the structure is shared among threads manually.  A pure data structure based on
finger trees \citep{hinze2006finger} known as a sequence turns out to be an ideal choice of structure. Concatenation in this structure is constant time, and splitting and lookup are logarithmic.
This is only slightly worse than the constant lookup time for a vector, and automatically
shares relevant unchanged sections between threads.


