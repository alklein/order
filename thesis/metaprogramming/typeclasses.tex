\section{Typeclasses}


I've mentioned previously that implicit arguments along side polymorphism and proof search can subsume Haskell style type classes.

The easiest way to see this is through an implementation of what is known as the ``Show'' type class in Haskell.  
In a logic programming language, a predicate that can be used to print a datatype can also be used to read a datatype, so here we shall discuss a ``serialize'' type class.


\begin{figure}[H]
\begin{lstlisting}

defn serializeBool : bool -> string -> type
  >| serializeBool-true = serializeBool true ``true''
  >| serializeBool-false = serializeBool false ``false''

\end{lstlisting}
\caption{Serializing booleans}
\label{prog:serializing}
\end{figure}


\begin{figure}[H]
\begin{lstlisting}

query readQuery = exists B : bool. serializeBool B ``true''
query printQuery = exists S : string . serializeBool false S

\end{lstlisting}
\caption{Bidirectional serializing}
\label{prog:bidi}
\end{figure}

Notice that the predicate \ref{prog:serialize} in the sense that both of the queries in 
\ref{prog:bidi} will resolve. 

The serialize predicate is a useful one and we would like it to be polymorphic in all types for which we've implemented a serialize function.  This is possible using implicit arguments.

We'd first create an open type for the type class serializable.

\begin{figure}[H]
\begin{lstlisting}

open serializable : [T]{ serializer : T -> string -> type } type

\end{lstlisting}
\caption{The type of the type class serializable }
\label{prog:sty}
\end{figure}

We'd then define a function ``serialize'' which unpacks the the implicit dependency of the type serializable.


\begin{figure}[H]
\begin{lstlisting}

defn serialize : {T}{ serializable : T -> string -> type } T -> string -> type
   | serializeImp = 
       [ Serializer : T -> string -> type ]
       [ Serializable : serializable T { serializer = Serializer }]
       serialize { serializable = Serializable } V S
     <- Serializer V S

\end{lstlisting}
\caption{The implementation of the function serialize }
\label{prog:imp}
\end{figure}


\begin{figure}[H]
\begin{lstlisting}

instance serialize-bool = serializable bool { serializer = serializeBool }
instance serialize-nat = serializable nat { serializer = serializeNat }

\end{lstlisting}
\caption{ Instances of serializable }
\label{prog:inst}
\end{figure}


To implement an instance of the serializable type class, one would add an instance axiom to the environment as in \ref{prog:inst}

Use of the function would then omit the implementation of the ``serializable'' argument and type argument such that they might be resolved automatically as in \ref{prog:uses}


\begin{figure}[H]
\begin{lstlisting}

query readQueryBool = exists B . serialize B ``true''
query printQueryBool = exists S . serialize false S

query printQueryNat = exists S . serialize (succ (succ zero)) S
query readQueryNat = exists S : nat . serialize S ``(succ (succ zero))''

\end{lstlisting}
\caption{ Instances of serializable }
\label{prog:inst}
\end{figure}


This process can be extended to not only open type classes, but closed typeclasses where 
resolution involves arbitrary computation.  
While it is difficult to point to uses of this capability that can be discussed in these confines,
type class computation has been known to the Haskell community for quite some time and has been used in application ranging from embedding an imperative computation monad with local variable use and 
assignment rules similar to those of C, to an RPC framework which creates end points based on functions with arbitrarily complex type signatures.
