\section[Background]{Background}

\subsection{History}
\begin{frame}
\frametitle{History}

\begin{itemize}
\item Prolog generalized pattern matching with backtracking logic programming.
\item $\lambda$Prolog gave prolog closures \citep{miller1988overview}.
\item Twelf \citep{pfenning1999system} gave a $\lambda$Prolog like language with with dependent types.
\end{itemize}
\end{frame}

%------------------------------------------------
\begin{frame}
\frametitle{Twelf}
\begin{itemize}
\item It lacks polymorphism and thus useful libraries
\item It can search for proofs as the method of programming 
\item It does does not use these found proofs as programs
\item Very good for theorem proving
\item No IO
\end{itemize}

\end{frame}

%------------------------------------------------
\subsection{Caledon}
\begin{frame}

\frametitle{Caledon}
\begin{itemize}
\item Caledon, turns twelf into a general purpose language
\item Has implicit multi-universe polymorphism
\item Has IO
\item Has nondeterminism control
\item Has instance arguments
\item Instance arguments support adhoc typeclasses
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{Dependent types and Proof Search}
\begin{itemize}

\item Dependent types allows you to mention code in your types.
\item Type inference allows you to generate types from your code.
\item Logic programming allows you generate code from your code.
\item since code is used in types, use logic programming for type inference to generate types for your code.
\item since types are used as logic programming code, type inference should come up with logic code.

\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{Result}
\begin{itemize}

\item types get inferred types which get inferred types... 
\item type inference becomes the runtime mechanism.

\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{Mechanism}
\begin{itemize}

\item Proof holes get filled by unification, then proof search.
\item Instance arguments allow for the automatic insertion of holes.
\item polymorphism permits generalization to logic programs in general.

\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{Uses}
\begin{itemize}

\item Programs which have different types on different computers, or for different users.
\item Metaprogramming for flexible syntax.
\item Take derivatives of types to generate types for zipper datastructures.
\item Ensure linearity of a type.

\end{itemize}

\end{frame}

%------------------------------------------------

