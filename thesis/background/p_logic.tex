\section[Logic Primer]{Logic Programming Primer}

\begin{frame}[fragile]
\frametitle{Logic Programming Basics}

\begin{lstlisting}
defn add : nat -> nat -> nat -> prop
   | addZ = add zero A A
   | addS = add (succ A) B (succ C) 
             <- add A B C
\end{lstlisting}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Comparing it to Haskell}

\begin{lstlisting}
add :: nat -> nat -> nat
add Zero a = a
add (Succ a) b = Succ c
   where c = add a b
\end{lstlisting}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{Uses for Logic programming}
\begin{itemize}
\item Search allows for nondeterministic programs.
\item Finding solutions for search games - tic-tac-toe
\item A procedural view can be used
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Procedural View}

\begin{lstlisting}
defn p : T_1 -> ... -> T_r -> prop
  >| n1 = p T_1 ... T_r <- p_1,1 ... <- p_1,k_1
...
  >| nN = p T_1 ... T_r <- p_n,1 ... <- p_n,k_n

query prg = p t1 ... tr
\end{lstlisting}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Function Match}

Here's some unnecessarily verbose code.

\begin{lstlisting}
func (Var a) = code1
func (Forall var val) = Exists var code
func (Exists var val) = Forall var code
func (And a b) = code2
\end{lstlisting}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Logic Version}

Here's the logic solution

\begin{lstlisting}
defn func : term -> term -> prop 
  | f1 = func (var A) R <- [code1]
  | f2 = func (F Var Val) (f Var R) <- [code]
  | f3 = func (and A B) R <- [code2]
\end{lstlisting}
\end{frame}

%------------------------------------------------
\subsection{Type Classes}
%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Type classes in Haskell}

Type classes in haskell allow you to append constraints
to paramaterized values.

\begin{lstlisting}
show :: Show a => a -> String
\end{lstlisting}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
\frametitle{Type classes in Caledon}

In Caledon we do this with an implicit argument.
\begin{lstlisting}
defn show : showC A => A -> String
defn show : {unused : showC A } A -> string
\end{lstlisting}
\end{frame}
