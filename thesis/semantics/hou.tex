\section{Higher Order Unification}

Unification lies at the heart of the semantics of the Caledon language.

Checking for the reducability of two full lambda terms has long been known to be only semidecidable.  
The matter becomes even more complicated when checking for the equality of terms with variables bound
by both existential and universal quantifiers.  Research from the past thirty years has constrained
the problem to the a decidable subset where unification is decidable. 


\subsection{History}

Miller \citep{miller1986higher} gave the first semidesicion algorithm for unification of 
terms in the lambda calculus.  
Later, it was proven by Pfenning \citep{pfenning1988partial} \citep{pfenning1988higher} 
that for terms in the pattern fragment of the lambda calculus, unification was decidable.  
Elliott\citep{elliott1989higher} gave a more efficient algorithm for unification in the context 
of dependent types, and later Pfenning \citep{pfenning1991unification}
did the same thing for unification in the Calculus of Constructions, although without a mixed prefix.  
The most succinct presentation comes from the 1991 paper describing the workings of Twelf 
\citep{pfenning1991logic}.  While the unification algorithm implemented in the interpreter for Caledon is 
an extention of that presented in Pfenning's 1991 paper on unification for 
the Calculus of Constructions\citep{pfenning1991unification}, 
I will briefly cover the main ideas from the presentation of the paper describing the workings of Twelf, 
and extend them later.

\subsection{Pattern Calculus}

\begin{definition}
Pattern Calculus
\[
T ::= P
   \orr \lambda V : T . P 
\]

\[
P ::= V 
  \orr P T 
\]
\end{definition}

Note that we will write $\Pi V : T . P$ as a synonm for $\Pi\; T \; (\lambda V : T . P)$ in the rest of the paper.
This simplifies the presentation of the unification algorithm, as then $\Pi$ can be considered a traditional constructor
that can also be used to direct the unification procedure.

Pattern terms have the incredibly useful property that if they are always in strong head normal form, meaning
that the head of every term is a constructor, and every argument is either a constructor or lambda term.

Of course, $V$ is the set of variables here.
To discuss unification in more detail, substitution for the pattern the pattern calculus
needs to be defined.

\begin{definition}
Hereditary Substitution is defined by the following mutual recurrence

\begin{figure}[H]

\[
[S/x] x := S
\]

\[
[S/x] y := y
\]

\[
[S/x] P T := \m{H}([S/x] P, [S/x]T)
\]

\[
[S/x] \lambda v : T . P := \lambda v' : [S/x]T . [S/x][v'/v]P
\] where $v'$ is new.

\[
\m{H}(\lambda v : T . P , A) := [S/v] A
\]

\[ 
\m{H}(P A_1 , A_2) := P\;A_1\;A_2
\] 

\[ 
\m{H}(V , A) := V\; A
\] 
\caption{Macros for expressive syntax}
\label{def:hered}
\end{figure}

\end{definition}

It is important to note the alpha conversion in the $\lambda$ case, as alpha conversion will be lost on 
some terms when implicits are added.

Hereditary Substitution has the unfortunate property that it is not necessarily a complete function:

\[
[(\lambda x . x\; x) / x ] ( x \; (\lambda x . x\; x) )
\]

is not defined, as it expands to the well known $\m{H}(\lambda x . x \; x , \lambda x . x \; x)$.

Fortunately, if the pattern and substitution are well typed terms in the calculus of constructions, by 
strong normalization, hereditary substitution is total.

\begin{theorem} Substitution Theorem:

If $\Gamma,x : T \vdash A : T' : \m{prop}$  and $\Gamma \vdash S : T : \m{prop}$ then
$ \Gamma \vdash [S/x]_o A : [S/x]_o T' : \m{prop}$
\end{theorem}

By consistency, $[S/x]_o A $ can be normalized to strong head normal form.  Thus, the 
hereditary substitution $[S/x] A$ is defined. Proofy

\subsection{Unification Terms}

\begin{definition}
Unification Terms:

\[
U ::= U \wedge U 
 \orr \forall V : T . U
 \orr \exists V : T . U 
 \orr U \doteq U
 \orr \top
\]

\end{definition}

When $\doteq$ is taken to mean $\equiv_{\beta\eta\alpha*}$, the unification problem is to determine 
whether a statement $U$ is ``true'' in the common sense, and provide a proof of the truth of the statement. 

Unification problems of the form 
$\forall x : T_1 . \exists y : T_2 . U $ can be converted to the form
$\exists y : \Pi x : T_1 . T_2 . \forall x : T_1 . [y\; x / y ]U $ 
in the process known as raising. Unification
statements can always quantified over unused variables: $U \implies Q x : T . U$.  

Thus, statements can always be converted to the form
\[
\exists y_1 \cdots y_n . \forall x_1 \cdots x_k . S_1 \doteq V_1 \wedge \cdots S_r \doteq V_r
\]

In this form, we might ask for a unification proof as a substitution

\begin{definition}
A unification solution is a substitution $\theta$ 
mapping existentially quantifed
variables to closed form lambda terms such 
that $\theta (S_1 \doteq V_1 \wedge \cdots S_r \doteq V_r)$
is provable trivially. 
\end{definition}

